//
//  CoverPickerViewModel.swift
//  CoverMe
//
//  Created by Cormell, David - DPC on 08/02/2023.
//

import Foundation

class CoverPickerViewModel: ObservableObject {
    static private let defaultLesson = Lesson.Monday2nd
    let timetable: Timetable
    let termDates: TermDates
    let coverManager: CoverManager
    @Published var availableCoverAllDay: [Lesson: [CoverArrangement]] = [:]
    @Published var selectedTeacherInitials: String
    @Published var selectedDate: Date = Date.now
    @Published var coverRecord: [CoverArrangementWithDate] = [] {
        didSet {
            self.saveCoverRecord()
        }
    }
    
    //TODO replace to dependency inject TimetableFileReader and CoverManager
    init() {
        let timetable = TimetableFileReader.createTimetableFromFile(filename: "timetable")
        self.timetable = timetable
        self.coverManager = CoverManager(timetable: timetable)
        let initialTeacher = timetable.team.first ?? Teacher(initials: "Unknown")
        self.selectedTeacherInitials = initialTeacher.initials
        let termDates = TermDatesFileReader.createTermDatesFromFile(filename: "termdates")
        self.termDates = termDates
        
    }
    
    func addAutogeneratedCover() {
        let bestCoverOptions = coverManager.getBestCoverOptions(date: selectedDate, teacher: Teacher(initials: selectedTeacherInitials), coverTally: getCoverTally())
        for cover in bestCoverOptions {
            addCoverArrangementWithDate(cover: cover)
        }
    }
    
    func addCoverArrangementWithDate(cover: CoverArrangement) {
        let coverArrangementWithDate = CoverArrangementWithDate(coverArrangement: cover, date: selectedDate, inSummer: termDates.isSummer(at: selectedDate))
        coverRecord.append(coverArrangementWithDate)
    }
    
    func updateAvailableCoverAllDay() {
        availableCoverAllDay = coverManager.getCoverOptions(date: selectedDate, teacher: Teacher(initials: selectedTeacherInitials))
    }
    
    func getLessonDisplay(lesson: Lesson) -> String {
        let timetabledLesson = timetable.getTimetabledLessonFor(lesson: lesson, teacher: Teacher(initials: selectedTeacherInitials))
        
        return CoverArrangementWithDate.getDisplay(text: timetabledLesson?.display ?? "", inSummer: termDates.isSummer(at: selectedDate))
    }
    
    func getLessonsTaughtOnDate() -> [Lesson] {
        let lessonsTaught = Lesson.allCases.filter({
            timetable.doesTeachIn($0, for: Teacher(initials: selectedTeacherInitials))
        })
        
        let lessonsTaughtOnDate = lessonsTaught.filter({
            let currentDay = selectedDate.day
            return currentDay == $0.dayOfWeek
        })
        
        return lessonsTaughtOnDate
        
    }
    
    func confirmCover(_ cover: CoverArrangementWithDate) {
        cover.confirm()
        self.saveCoverRecord()
        objectWillChange.send()
    }
    
    func removeCoverFromRecord(_ cover: CoverArrangementWithDate) {
        coverRecord.removeAll(where: {
            $0 == cover
        })
    }
    
    func getTeamInitials() -> [String] {
        return timetable.team.map({ $0.initials })
    }
    
    func getCoverTally() -> [Teacher:Int] {
        var dictionary: [Teacher:Int] = [:]
        let confirmedCover = coverRecord.filter({
            $0.status == .confirmed
        })
        
        for teacher in timetable.team {
            dictionary[teacher] = 0
        }
    
        for cover in confirmedCover {
            dictionary[cover.coverArrangement.coverTeacher]! += 1
        }
        
        return dictionary
    }
    
    func saveCoverRecord() {
        FileManager.default.save(to: "coverRecord.json", object: coverRecord)
    }
    
    func restoreCoverRecord() {
        if let loadedCoverRecord: [CoverArrangementWithDate] = FileManager.default.load(from: "coverRecord.json") {
            coverRecord = loadedCoverRecord
        }
    }
}
